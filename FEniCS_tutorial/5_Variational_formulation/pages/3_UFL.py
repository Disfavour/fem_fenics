import streamlit as st


r"""
# UFL

Unified Form Language (UFL) - специальный язык, ориентированный на предметную область, для определения дискретных
вариационных форм и функционалов в обозначениях близких к математическим.

- v, c, d  - скалярные функции.


## Интегралы

Интегралы выражаются путем умножения на меру, представляющую собой интеграл по

- внутренней части области "dx",
- границе области "ds",
- множеству внутренних граней "dS" (interior facet integral).

Интеграл по области:

```python
a = v * dx
```

Интеграл по границе области:

```python
a = v * ds
```

Меры могут быть переопределены для представления пронумерованных подмножеств области, так что будут получаться разные
выражения в разных частях домена.

Например,

```python
c*dx + v*ds(0) + d*ds(1)
```

эквивалентно

$$
\int \limits_\Omega c \ dx + \int \limits_{\partial \Omega_0} v \ ds + \int \limits_{\partial \Omega_1} d \ ds.
$$

Численное вычисление реализовано функцией `assemble()`. Например, вычисление $\displaystyle \int \limits_\Omega c\ dx$:

```python
assemble(c*dx)
```


## Индексы

Тип данных `Index` используется для указания степени производных и для получения компонентов нескалярных выражений.

`Index` может быть создан с помощью `Index()`. Множество индексов может быть создано с помощью `indices(n)`:

```python
i = Index()
j, k, l = indices(3)
```


## Производные

В FEniCS координаты `x[0], x[1], ..., x[n-1]` соответствуют координатам $x_1, x_2, \dots, x_n$.

Производная функции v по координате с "номером" k:

```python
Dx(v, k)
```

или

```python
v.dx(k)
```

Сумма производных

$$
g = \sum_i \frac {\partial v} {\partial x_i}
$$

записывается в виде

```python
g = Dx(v[i], i)
```

или 

```python
g = v[i].dx(i)
```


## Градиент

В UFL следующие пары объявлений эквивалентны:

```python
Dfi = grad(f)[i]
Dfi = f.dx(i)

Dvi = grad(v)[i, j]
Dvi = v[i].dx(j)

DAi = grad(A)[..., i]
DAi = A.dx(i)
```

для скалярного выражения f, векторного выражения v и тензорного выражения A произвольного ранга.


## Дивергенция

В UFL следующие пары объявлений эквивалентны:

```python
dv = div(v)
dv = v[i].dx(i)

dA = div(A)
dA = A[..., i].dx(i)
```

для векторного выражения v и тензорного выражения A.


## Ротор

В UFL следующие объявления эквивалентны:

```python
omega = curl(v)
omega = rot(v)
```

## Скалярное произведение

Скалярное произведение двух тензоров a и b может быть записано:

```python
# Тензоры a и b
f = dot(a, b)

# Векторы a и b
f = a[i]*b[i]

# Матрицы a и b
f = as_matrix(a[i,k]*b[k,j], (i,j))
```

В ортонормированном базисе евклидова пространства скалярное произведение единичных векторов:

$$
\bold{i}_i \cdot \bold{i}_j = \delta_{ij}
$$

где $\delta_{ij}$ - символ Кронекера.

Из этого следует скалярное произведение тензоров более высокого порядка.

Пример с двумя векторами:

$$
\vec{a} \cdot \vec{b} = (a_i \bold{i}_i) \cdot (b_j \bold{i}_j) = a_i b_j (\bold{i}_i \cdot \bold{i}_j)
= a_i b_j \delta_{ij} = a_i b_i.
$$

Пример с тензором второго ранга:

$$
A \cdot B = (A_{ij} \bold{i}_i \bold{i}_j) \cdot (B_{kl} \bold{i}_k \bold{i}_l)
= (A_{ij} B_{kl}) \bold{i}_i (\bold{i}_j \cdot \bold{i}_k) \bold{i}_l
= (A_{ij} B_{kl} \delta_{jk}) \bold{i}_i  \bold{i}_l
= (A_{ik} B_{kl}) \bold{i}_i  \bold{i}_l
$$

Это то же самое, что умножение матриц.


## Внутреннее произведение

Если $A$ и $B$ - тензоры 2-го ранга, а $C$ и $D$ - тензоры 3-го ранга, то их внутренние произведения равны:

$$
\begin{aligned}
& A : B = A_{ij} B_{ij}^*,
\\[0.5 cm]
& C : D = C_{ijk} D_{ijk}^*;
\end{aligned}
$$

где * - комплексное сопряженное.

Используя обозначение UFL, для вещественных значений эквивалентны следующие наборы объявлений:

```python
# Векторы
f = dot(a, b)
f = inner(a, b)
f = a[i]*b[i]

# Матрицы
f = inner(A, B)
f = A[i,j]*B[i,j]

# Тензоры 3-го ранга
f = inner(C, D)
f = C[i,j,k]*D[i,j,k]
```
"""
