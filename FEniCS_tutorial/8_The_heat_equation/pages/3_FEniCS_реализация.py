import streamlit as st


r"""
# FEniCS реализация

Проблема заключается в том, как работать с функциями, которые изменяются в пространстве и времени, такими как граничные
условия. Естественным решением является использование Expression со временем $t$ в качестве параметра, в дополнение к
параметрам $a$ и $b$:

```python
alpha = 3; beta = 1.2
u_D = Expression("1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t", degree=2, alpha=alpha, beta=beta, t=0)
```

Это выражение использует компоненты $x$ в качестве независимых переменных, в то время как alpha, beta и t являются
параметрами. Время t позже может быть обновлено с помощью

```python
u_D.t = t
```

Существенные граничные условия, в данном случае вдоль всей границы, реализуются обычным образом:

```python
bc = DirichletBC(V, u_D, "on_boundary")
```

Будем использовать `u` для $u^{n+1}$ на новом временном шаге и `u_n` для $u^n$ на предыдущем временном шаге.

Начальное значение `u_n` может быть вычислено либо с помощью проекции, либо с помощью интерполяции $u_0$.
Поскольку мы устанавливаем `t = 0` для граничного значения `u_D`, мы можем использовать `u_D` для указания начального
условия:

$$
u_n = project(u_D, V)
# или
u_n = interpolate(u_D, V)
$$

Чтобы фактически восстановить точное решение с машинной точностью, важно вычислить дискретное начальное условие путем
интерполяции (`interpolate`) u0. Это гарантирует, что степени свободы являются точными при t = 0.
Проекция (`project`) приводит к приблизительным значениям в узлах.

Мы можем либо определить $a$ или $L$, либо мы можем просто определить $F$ и попросить FEniCS выяснить, какие члены
должны входить в билинейную форму $a$, а какие - в линейную форму $L$.
Последнее удобно, особенно в более сложных задачах.

```python
u = TrialFunction(V)
v = TestFunction(V)
f = Constant(beta - 2 - 2*alpha)
F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_n + dt*f)*v*dx
a, L = lhs(F), rhs(F)
```

Наконец, мы выполняем шаг по времени в цикле:

```python
u = Function(V)
t = 0
for n in range(num_steps):
    # Обновляем время
    t += dt
    u_D.t = t
    # Вызываем решатель
    solve(a == L, u, bc)
    # Обновляем предыдущее решение
    u_n.assign(u)
```

На последнем шаге цикла с шагом по времени мы присваиваем значения переменной `u` (новое вычисленное решение)
переменной `u_n`, содержащей значения на предыдущем шаге по времени. Это должно быть сделано с помощью метода
`assign`. Если мы вместо этого попытаемся сделать `u_n = u`, мы установим переменную `u_n` такой же переменной, как `u`,
что не является тем, что мы хотим.
(Нам нужны две переменные, одна для значений на предыдущем временном шаге и одна для значений на текущем
временном шаге.)
"""

with st.expander("Программная реализация"):
    r"""
```python
from fenics import *
import matplotlib.pyplot as plt


T = 2.0
num_steps = 50
dt = T / num_steps

nx = ny = 30
mesh = RectangleMesh(Point(-2, -2), Point(2, 2), nx, ny)

V = FunctionSpace(mesh, "P", 1)

bc = DirichletBC(V, Constant(0), "on_boundary")

u_0 = Expression("exp(-a*pow(x[0], 2) - a*pow(x[1], 2))", degree=2, a=5)
u_n = interpolate(u_0, V)

u = TrialFunction(V)
v = TestFunction(V)
f = Constant(0)
F = u*v*dx + dt*dot(grad(u), grad(v))*dx - (u_n + dt*f)*v*dx
a, L = lhs(F), rhs(F)

u = Function(V)
t = 0
for n in range(num_steps):
    # Обновляем время
    t += dt
    # Считаем u на следующем шаге
    solve(a == L, u, bc)

    plot(u)
    plt.show()

    # Обновляем результат предыдущего шага
    u_n.assign(u)
```
    """
